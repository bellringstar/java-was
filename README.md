# Java WAS

2024 우아한 테크캠프 프로젝트 WAS

### 20240704 TODO
- [ ] kep-alive 동작을 위해 소켓 처리 방식 변경
  - [ ] 쓰레드 내에서 해당 Socket 객체의 연결을 유지하는 방식으로 처리
  - [ ] keep-alive 헤더와 connection 헤더를 파싱해 처리하도록 변경
  - [ ] 타임아웃 설정
- [x] 라우터, 리퀘스트 핸들러 도입. url 별로 처리할 수 있도록 변경
  - [x] 라우터를 통해 경로별로 리퀘스트 핸들러를 등록
  - [x] 리퀘스트가 들어오면 라우터를 통해 해달 리퀘스트 핸들러를 찾고 리퀘스트 객체 처리를 넘긴다.
    - [x] 핸들러는 request객체 내의 메서드 정보를 읽어 거기에 맞는 처리를 한다.
  - [x] 해당 핸들러는 리스폰스를 만들어 리턴을 한다.
  - [x] 경로 매핑을 위한 정규표현식 -> 일단 정규식이 아니라 매치 방식으로 구현
  
- 고민
  - 라우터는 여러 쓰레드에서 동시에 접근하고 사용할것이다. 쓰레드 세이프티를 어떻게 구현할거지
    - 생성 자체는 싱글톤으로 생성해서 관리. Holder 패턴으로 생성 시 스레드 세프티 보장
    - 동작에서의 스레드 세이프티가 중요한데.. -> get 메서드만 스레드 세이프티가 중요한데 어차피 concurrentHashMap을 사용중이라 괜찮다.
  - 리퀘스트 핸들러를 어떻게 처리하지
    - 인터페이스 하나에 handle 메서드를 두고 구현체에서 메서드별로 처리한다
      - 근데 이러면 핸들러 만들 때 마다 반복작업이 많아지고 클래스가 커질 것 같다.
    - 인터페이스를 메서드별로 나눈다.
      - RequestHandler를 상속받은 GetRequestHandler, PostRequestHandler... 
      - 이러면 책임이 명확해지는데 인터페이스가 너무 많아진다.
      - 또 구현체를 메서드별로 만들어야한다.
    - 추상 클래스로 추상계층을 하나 더 만든다.
      - 가장 무난할 듯?
      - 애초에 핸들러를 구현하는 클래스들은 모두 get, post, put, delete등의 동작을 할 가능성이 있다.
      - 재사용성이 높고 지원하지 않는 메서드 처리도 편리해진다.
  - 전체 흐름을 변경해야겠다.
    - 기존: 소켓 생성 -> 별도 스레드에서 requestHandler에서 파싱 -> 파일을 찾고 -> 리스폰스로 만들어 리턴 인데
    - 변경: 소켓 생성 -> 별도 스레드에서 파싱해 -> 파싱된 정보로 request생성, handler 찾기 -> handler에서 리스폰스 생성 -> 리턴 